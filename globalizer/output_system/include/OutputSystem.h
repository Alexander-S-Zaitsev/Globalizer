#pragma once

#include <iostream>
#include <fstream>
#include <sstream>
#include <string>

// ------------------------------------------------------------------------------------------------
/**
Базовый класс, реализует вывод на консоль

*/
class OutputHelper { };

// ------------------------------------------------------------------------------------------------
/**
Базовый класс, реализует вывод на консоль справки первого уровня

Вывод происходит только если определены константы GLOBALIZER_OUTPUT_L1 или GLOBALIZER_OUTPUT_L2
*/
class OutputLevel1Helper { };

// ------------------------------------------------------------------------------------------------
/**
Базовый класс, реализует вывод на консоль справки второго уровня

Вывод происходит только если определена константа GLOBALIZER_OUTPUT_L2
*/
class OutputLevel2Helper { };

// ------------------------------------------------------------------------------------------------
/**
Базовый класс, реализует вывод на консоль отладочной информации

Вывод происходит только в debug версии (т.е. если определена константа _DEBUG)
*/
class OutputDebugHelper { };

// ------------------------------------------------------------------------------------------------
class LogDebugHelper;

// ------------------------------------------------------------------------------------------------
/**
Основной класс, реализует вывод в файл
Печать только в debug конфигурации
*/
class Logger
{
protected:
  /// Поток вывода в файл
  std::fstream mLogOutputStream;
  /// Имя лог файла
  static std::string mLogFileName;
  /// Была ли проинициализирована иситема
  static bool mIsInitialized;

  ~Logger() {}
  Logger();
  Logger(const Logger&) {}
  Logger& operator=(const Logger&) {return *this;}

  template<typename T>
  friend inline LogDebugHelper& operator<<(LogDebugHelper& incomingHelper, const T& value);
public:
  /// Очистка потока вывода в файл
  void flush();
  /**
  Инициализация класса, необходимо вызвать перед работой, принимает имя лог файла
  \param[in] logFileName - имя файла в который будет произвадиться печать
  \param[in] isFlush - очищать ли файл
  */
  static void init(const std::string& logFileName);
  /// Возвращает экземпляр объекта
  static Logger& instance();
};

// ------------------------------------------------------------------------------------------------
/**
Базовый класс, реализует вывод в файл отладочной информации

Вывод происходит только в debug версии (т.е. если определена константа _DEBUG)
*/
class LogDebugHelper
{
  public:
    void flush()
    {
      Logger::instance().flush();
    }
};

// ------------------------------------------------------------------------------------------------
/// Глобальная переменная для вывода отладочной информации (всесто cout)
extern OutputDebugHelper print_dbg;
/// Глобальная переменная для вывода на консоль (всесто cout)
extern OutputHelper print;
/// Глобальная переменная для выода отладочной информации первого и второго уровня
extern OutputLevel1Helper print_l1;
/// Глобальная переменная для выода отладочной информации второго уровня
extern OutputLevel2Helper print_l2;
/// Глобальная переменная для печати отладочной информации в лог
extern LogDebugHelper print_dbg_file;

// ------------------------------------------------------------------------------------------------
template<typename T> inline
OutputHelper& operator<<(OutputHelper& incomingHelper, const T& value)
{
  std::cout << value;
  return incomingHelper;
}

// ------------------------------------------------------------------------------------------------
template<typename T> inline
OutputLevel1Helper& operator<<(OutputLevel1Helper& incomingHelper, const T& value)
{
#if defined(GLOBALIZER_OUTPUT_L1) || defined(GLOBALIZER_OUTPUT_L2)
  std::cout << value;
#endif
  return incomingHelper;
}

// ------------------------------------------------------------------------------------------------
template<typename T> inline
OutputLevel2Helper& operator<<(OutputLevel2Helper& incomingHelper, const T& value)
{
#ifdef GLOBALIZER_OUTPUT_L2
  std::cout << value;
#endif
  return incomingHelper;
}

// ------------------------------------------------------------------------------------------------
template<typename T> inline
OutputDebugHelper& operator<<(OutputDebugHelper& incomingHelper, const T& value)
{
#ifdef _DEBUG
  std::cout << value;
#endif
  return incomingHelper;
}

// ------------------------------------------------------------------------------------------------
template<typename T> inline
LogDebugHelper& operator<<(LogDebugHelper& incomingHelper, const T& value)
{
#ifdef _DEBUG
  Logger::instance().mLogOutputStream << value;
#endif
  return incomingHelper;
}

// ------------------------------------------------------------------------------------------------
template<typename T>
std::string toString (T value)
{
  std::ostringstream oss;
  oss << value;
  return oss.str();
}
